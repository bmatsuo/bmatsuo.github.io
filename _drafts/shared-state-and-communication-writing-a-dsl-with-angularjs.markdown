---
layout: post
title: "Shared State and Communication: Writing a DSL with AngularJS"
date: 2014-01-23 00:08:26 -0800
categories: angularjs
---

**TL;DR** If you write a DSL, expose factories and the use the `require`
directive property to communicate and share data in a limited scope.

I recently learned about directives in AngularJS and they've kind of taken over
how I think about things in Angular. Directives just seem like awesome blobs of
modular interface functionality in their little
[isolate scope](https://github.com/angular/angular.js/wiki/Understanding-Scopes)
worlds. Things have gotten to the point where I'm pretty sure I'm using
directives too much.

A guideline that seems approximately correct to me is that directives should be
used for 'lightweight', 'semi-transparent' processes meant to transform raw data
to a human consumable format. I'm not going to define those terms. Anyway, I
don't think business logic should be contained in directives. But, what if there
is logic that's not __your__ business logic? This idea inspired me to write a
DSL in AngularJS which accomplishes the same things as the
[Swagger](https://developers.helloreverb.com/swagger/)
project (specifically, the functionality of
[Swagger UI](https://github.com/wordnik/swagger-ui)).
The name of my project is, __tenatively__,
[RestML](https://github.com/bmatsuo/restml).

The idea of the DSL is that the person integrating has complete control over the
documentation and API playground UI while there are directives under the covers
providing an abstraction over the specification and managing all the
request-response behavior of the API playground. Integration is hosting single
HTML 5 document, along with whatever stylsheets/extra javascripts you want to
include. This post is going to talk about API playground implementation.

So let's talk about an HTTP _action_, a method and url (with associated
query/body parameters). In the RestML DSL this contains a set of parameters,
a request, and a response. This is a simplified view of the DSL.

{% highlight xml %}
    <rest-action ng-repeat="action in resource.actions">
        <ul class="params">
            <li ng-repeat="param in action.params">
                <rest-param-label for="param.name"></rest-param-label>
                <rest-param-input name="param.name"></rest-param-input>
                <rest-submit>Go!</rest-submit>
            </li>
        </ul>
        <div class="request">
            <rest-request-url></rest-request-url>
            <rest-request-header></rest-request-header>
            <rest-request-body></rest-request-body>
        </div>
        <div class="response">
            <rest-response-status></rest-response-status>
            <rest-response-header></rest-response-header>
            <rest-response-body></rest-response-body>
        </div>
    </rest-action>
{% endhighlight %}

What is going on here? The rest-&ast; elements have AngularJS directives
(mini-controllers) backing them. So each element has an associated template with
access to the directive's isolate scope. The content inside the directive
element, however, cannot see the isolate scope and instead sees the scope
outside the element. Furthermore, the isolate scopes of different directive
elements do not have direct contact. I'm not sure if it's possible to access
directive controllers through the DOM. But I don't want to bend over backwards,
that sounds like a bad design.

So, what is supposed to happen here? The user clicks the button generated by the
restSubmit directive. This triggers values copied from each restParamInput field
to be structured in an HTTP request (which is available to the restRequest&ast;
directives) and issued with XHR. The response data is made available to the
restResponse&ast; directives when it is available. Oh, and the inputs/buttons
disable themselves when the request is in flight. Well, that's quite a bit of
coordination between components. How do we manage this with all these isolate
scopes?

**Disclaimer:** the exact DSL does not look like I've depicted above, and not all
of the functionality describes works. But a working proof of concept version
exists that will move toward what is said here.

There are a couple devices Angular provides which can act as liferafts. There
are things like services, singleton objects which can be depended upon by
multiple directives and used for communication. Ok. that sounds cool But I have
a lot of `<rest-action>` elements on a page. The lines of commonication cannot
get crossed. And regardless, a "scoped" (not necessarily in an Angular sense)
solution sounds like a cleaner design, if achievable. A solution where events
from different directives are not processed in a global manner, but one limited
to whatever restAction directive contains it.

Deep in the [directives guide](http://docs.angularjs.org/guide/directive) you
will find information about the `require` property. This turns out to provide
exactly what's needed. It enforces a policy that the directive must be contained
(at any depth) within another (set of) directives. It __also__ gives the
directive access to the specified ancestors' controllers. Nice. So, in my case,
the restAction constructor exposes public methods on the controller and allows
a scoped communication between its rest&ast; descendents.

My first implementation went all `require`. Descendents register callbacks for
data managed by other controllers and emit events/data when something
scope-local changes.  The easiest way to achive this was basically exposing the
restAction's `scope.$watch` method. This did not seem like a good idea. But it
was quick and easy. I talked to a coworker whom I trust for guidance on the
matter and he was suggested that services were the more accepted solution for
communication between directives. Ok, I thought, I will have the restAction
generate some ID for its descendents to use communicating with each other
through a singleton service. Not awful. But not ideal.

I mulled the advice from my coworker over for a day, not completely satisfied.
Then I realized there was indeed another way. Factories. A factory is similar in
functionality to a service. But factories are not singleton. A unique factory
instance is given to each controller/directive instance that references it.  
Now I have it! The restAction exposes a public factory instance which acts as
a channel for communication between descendents! But what has changed?

So (ignoring exposure of `scope.$watch`) I can expose some other eventing
system into the restAction controller, or an eventing system built into a
factory object. The difference is separation of concerns. The rest&ast;
directives are interface components. Enforcing structure and displaying data is
the most they should be responsible for. An eventing system and http request
performer is not an interface component.
